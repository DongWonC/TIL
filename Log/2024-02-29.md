# Django
___
# 1장 장고 개발 준비!

#### 웹 프레임워크란?
`웹 프레임워크(web framework)` : 웹 애플리케이션을 개발할 때 기본적인 구조와 기능들을 제공하여 개발자가 효율적으고 안정적으로 웹 애플리케이션을 구축할 수 있도록 돕는 도구 모음

## 1-03 장고 개발 환경 준비하기
### 파이썬 가상 환경 알아보기
`파이썬 가상 환경`은 파이썬 프로젝트를 진행할 때 독립적인 환경을 만들어 주는 도구이다.

가상 환경을 이용하면 하나의 PC에 서로 다른 버전의 파이썬과 라이브러리를 쉽게 설치해 사용할 수 있다.

### 파이썬 가상 환경 사용해 보기
윈도우에서 명령 프롬프트를 실행하고 다음 명령어를 입력해 `C:/venvs` 라는 디렉터리를 만들자.

```bash
C:\Users\ehddn> cd \
C:\> mkdir venvs
C:\> cd venvs
```

파이썬 가상 환경을 만드는 다음 명령어를 입력해 실행하자.

```bash
C:\venvs> python -m venv mysite
```

`python -m venv`는 **파이썬 모듈 중 venv라는 모듈을 사용한다**는 의미다. 그 뒤의 mysite는 생성할 가상 환경의 이름이다. 

가상 환경에 진입하려면 우리가 생성한 mysite 가상 솬경에 있는 Scripts 디렉터리의 `activate 명령`을 수행해야 한다. 다음 명령을 입력하여 mysite 가상 환경에 진입해 보자.

```bash
C:\venvs>cd C:\venvs\mysite\Scripts
C:\venvs\mysite\Scripts> activate
(mysite) C:\venvs\mysite\Scripts>
```

그러면 `C:/` 왼쪽에 (mysite)라는 프롬프트를 확인할 수 있다. 이름에서 볼 수 있듯 현재 진입한 가상 환경을 의미한다.

현재 진입한 가상 환경을 벗어나려면 `deactivate`라는 명령을 실행하면 된다. 

```bash
(mysite) C:\venvs\mysite\Scripts> deactivate
C:\venvs\mysite\Scripts>
```

가상 환경에서 벗어났다면 `C:/` 왼쪽에 있던 (mysite)라는 프롬프트가 사라졌을 것이다.

### 장고 설치
가상 환경에 진입한 상태에서 장고 설치를 진행하자.

```bash
C:\venvs\mysite\Scripts> activate
(mysite) C:\venvs\mysite\Scripts>
```

mysite 가상 환경에 진입한 상태에서 `pip install django==4.0.3` 명령을 입력하자. pip은 파이썬 라이브러리를 설치하고 관리해 주는 파이썬 도구이다.
## 1-04 장고 프로젝트 생성하기
장고에는 프로젝트라는 개념이 있는데, 장고의 프로젝트는 하나의 웹 사이트라고 생각하면 된다. 즉, 장고 프로젝트를 생성하면 한 개의 웹 사이트를 생성하는 것과 같다. 프로젝트 안에는 여러 개의 앱이 존재한다. 이 앱들이 모여 웹 사이트를 구성한다.

### 프로젝트 생성하기
장고 프로젝트는 여러 개가 될 수 있으므로 프로젝트를 모아 둘 프로젝트 루트 디렉터리 생성은 필수다. `C:\projects` 디렉터리를 프로젝트들의 루트 디렉터리로 정하고 진행하겠다.

```bash
C:\Users\ehddn> cd \
C:\mkdir projects
C:\> cd projects
C:\projects>
```

루트 디렉터리 `C:\projects` 를 생성하고 해당 디렉터리로 이동하였다.

그리고 다음처럼 mysite 가상환경에 진입하자.

```bash
C:\projects>C:\venvs\mysite\Scripts\activate
(mysite) C:\projects>
```

이제 장고 프로젝트를 생성할 차례이다. 먼저 파이보 프로젝트를 의미하는 mysite 디렉터리를 다음과 같이 생성한다.

```bash
(mysite) C:\projects> mkdir mysite
```

그리고 다음처럼 mysite 디렉터리로 이동한다.

```bash
(mysite) C:\projects> cd mysite
(mysite) C:\projects\mysite>
```

그리고 `django-admin startproject config .` 명령으로 장고 프로젝트를 생성하자.

```bash
(mysite) C:\projects\mysite>django-admin startproject config .
```

이때 config 다음에 점 기호(`.`)가 있음에 주의하자. 점 기호는 **현재 디렉터리**를 의미한다. 위 명령의 의미는 현재 디렉터리인 mysite를 기준으로 프로젝트를 생성하겠다는 의미이다. 프로젝트가 생성되면 mysite 디렉터리 밑에는 장고가 필요로 하는 여러 디렉터리와 파일들이 생성된다.

### 개발 서버 구동하고 웹 사이트에 접속해 보기
이제 mysite 프로젝트가 생성되었으니 mysite를 구동해 볼 차례이다.

다음처럼 `python manage.py runserver` 명령을 입력하자.

```bash
(mysite) C:\projects\mysite> python manage.py runserver
```

몇 가지 의미있는 정보들이 보이지만 그것들은 무시하고 가장 마지막에 보이는 문장만 주목해 보도록 하자.

```bash
Starting development server at http://127.0.0.1:8000/
Quit the server with CRTL-BREAK.
```

장고 서버가 `http://127.0.0.1:8000/`로 시작되었다는 것과 서버를 중지하기 위해서는 `CONTROL-C`를 입력하라는 내용이다.

> 이렇게 개발을 위해 실행되는 장고 서버를 로컬호스트(localhost)로 실행되기 때문에 로컬 서버라고 부른다. 이 책에서는 앞으로 이렇게 실행되는 장고 서버를 **로컬 서버** 또는 **개발 서버**라고 하겠다.

이제 웹브라우저를 열고 주소창에 `http://127.0.0.1:8000/`을 입력해 보자.

`http://127.0.0.1:8000/` 대신 `http://localhost:8000` 라고 입력해도 동일한 결과를 볼 수 있다.
127.0.0.1과 localhost는 모두 여러분의 PC를 가리키는 아이피 주소이기 때문이다. 다른 사람이 자신이 만든 사이트에 접속하려면 로컬 아이피가 아닌 고정 아이피 또는 pybo.kr과 같은 도메인이 필요하다.

### mysite 가상 환경에 간단히 진입하기
mysite 가상 환경에 진입하려면 매번 명령 프롬프트를 실행하고 `c:/projects/mysite` 디렉터리로 이동하여 `c:/venvs/mysite/scripts/activate` 명령을 수행해야 한다. 이런 일련의 과정을 한 번에 수행할 수 있는 배치 프로그램을 만들어 귀찮음을 덜어 보자.

다음과 같은 `mysite.cmd` 파일을 노트패드와 같은 에디터로 작성하자.

`[파일 이름: C:/venvs/mysite.cmd]`
```
@echo off
cd :/projects/mysite
c:/venvs/mysite/scripts/activate
```
> 확장자 `.cmd`가 붙은 파일은 배치(batch) 파일이라 부르며, 명령어 입력과 실행을 한 번에 해주는 파일이라 생각하면 된다.

배치 파일의 내용은 `C:/projects/mysite` 디렉터리로 이동한 다음, `C:/venvs/mysite/scripts/activate` 명령을 수행하라는 내용이다.

그리고 이 배치 파일이 명령 프롬프트 어느 곳에서나 수행될 수 있도록 하려면 `C:/venvs` 디렉터리를 시스템의 환경 변수 PATH에 추가해야 한다. 먼저 `<윈도우키+R>` 키를 입력하여 다음처럼 `sysdm.cpl` 명령을 입력하고 `<확인>`을 누르자.

그러면 '시스템 속성' 창이 나타난다. 여기서 `<고급>` 탭을 선택하고 `<환경 변수>` 버튼을 누르자.

그러면 '환경 변수' 창이 나타난다. 여기서 사용자 변수 중 `<Path>`를 선택하고 `<편집>` 버튼을 누르자.

그러면 '환경 변수 편집' 창이 나타난다. 여기서 `<새로 만들기>` 버튼을 누르자.

그리고 `C:\venvs` 디렉터리를 추가하고 `<확인>` 버튼을 누르자.

마지막으로 다음 '환경 변수' 창에서 `<확인>` 버튼을 누르자

이렇게 하면 환경 변수 PATH에 `C:\venvs` 디렉터리가 추가되어 `mysite.cmd` 명령을 어디서든 실행할 수 있다. 명령 프롬프트를 다시 시작하자(그래야 변경된 환경 변수 PATH가 제대로 반영된다.) 그리고 set path 명령을 실행하여 변경된 환경 변수 PATH의 내용을 확인해 보자. `C:\venvs` 라는 디렉터리가 환경 변수 PATH에 포함되어 있으면 된다.

```bash
C:\Users\ehddn> set path
```

이제 mysite 명령(배치 파일 이름)을 실행하여 가상 환경에 잘 진입하는지 확인해 보자. 윈도우에서 확장자가 `.cmd`인 파일은 확장자를 빼고 입력해도 된다.

```bash
C:\Users\ehddn> mysite
(mysite) C:\projects\mysite>
```

이제 명령창 아무곳에서 mysite만 입력하면 쉽게 mysite 가상환경으로 진입할 것이다.

### settings.py
장고 개발을 맛보는 차원에서 장고의 설정값이 들어 있는 settings.py 파일을 수정해 보자. 파이참에서 settings.py 파일을 열어 `LANGUAGE_CODE`와 `TIME_ZONE` 설정값을 수정하자. `LANGUAGE_CODE`를 en-us에서 ko-kr로 수정하고 `TIME_ZONE`을 UTC에서 Asia/Seoul로 수정했다. 언어와 시간을 한국 값으로 바꾼 것이다.

`[파일이름: projects/mysite/config/settings.py]`
```python
#(... 생략 ...)
LANGUAGE_CODE = 'ko-kr'

TIME_ZONE = 'Asia/Seoul'
```

앞의 실습을 잘 진행했다면 개발 서버가 종료된 상태일 것이다. 개발 서버를 다시 구동하자.

```bash
(mysite) c:\projects\mysite>python manage.py runserver
```

이제 `localhost:8000`으로 접속하면 초기 화면이 영어에서 한글로 바뀌어 있다.

# 2장 장고의 기본 요소 익히기!

___
# Git
# 시작하기
## 버전 관리란?

- `버전 관리 시스템(VCS - Version Control System)` : 파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템. 

VCS를 사용하면 각 파일을 이전 상태로 되돌릴 수 있고, 프로젝트를 통째로 이전 상태로 되돌릴 수 있고, 시간에 따라 수정 내용을 비교해 볼 수 있고, 누가 문제를 일으켰는지도 추적할 수 있고, 누가 언제 만들어낸 이슈인지도 알 수 있다. VCS를 사용하면 파일을 잃어버리거나 잘못 고쳤을 때도 쉽게 복구할 수 있다.

### 로컬 버전 관리
많은 사람들은 버전을 관리하기 위해 디렉토리로 파일을 복사하는 방법을 쓴다. 하지만, 작업하던 디렉토리를 지워버리거나, 실수로 파일을 잘못 고칠 수도 있고, 잘못 복사할 수도 있다.

이런 이유로 프로그래머들은 오래전에 로컬 VCS라는 걸 만들었다. 이 VCS는 아주 간단한 데이터베이스를 사용해서 파일의 변경 정보를 관리했다.

많이 쓰는 VCS 도구 중에 `RCS(Revision Control System)`라고 부르는 것이 있는데, RCS는 기본적으로 Patch Set(파일에서 변경되는 부분)을 관리한다. 이 Patch Set은 특별한 형식의 파일로 저장한다. 그리고 일련의 Patch Set을 적용해서 모든 파일을 특정 시점으로 되돌릴 수 있다.
#### 중앙집중식 버전 관리(CVCS)
프로젝트를 진행하다 보면 **다른 개발자와 함께 작업**해야 하는 경우가 많다. 이럴 때 생기는 문제를 해결하기 위해 `중앙집중식 버전 관리(CVCS)`가 개발됐다. CVS, Subversion, Perforce 같은 시스템은 파일을 관리하는 서버가 별도로 있고 클라이언트가 중앙 서버에서 파일을 받아서 사용(Checkout)한다. 

CVCS 환경은 관리자는 누가 무엇을 할지 관리할 수 있다. 모든 클라이언트의 로컬 데이터베이스를 관리하는 것보다 VCS 하나를 관리하기가 훨씬 쉽다.

그러나 이 CVCS 환경은 몇 가지 치명적인 결점이 있다. 가장 대표적인 것이 중앙 서버에 발생한 문제다. 만약 서버가 한 시간 동안 다운되면 그동안 아무도 **다른 사람과 협업할 수 없고** 사람들이 하는 일을 **백업할 방법도 없다**. 그리고 **중앙 데이터베이스가 있는 하드디스크에 문제가 생기면 프로젝트의 모든 히스토리를 잃는다**. 물론 사람마다 하나씩 가진 스냅샷은 괜찮다. 로컬 VCS 시스템도 이와 비슷한 결점이 있고 이런 문제가 발생하면 모든 것을 잃는다.

#### 분산 버전 관리 시스템
Git, Mecurial, Bazaar, Darcs 같은 `분산 버전 관리 시스템(DVCS)`에서의 클라이언트는 단순히 파일의 마지막 스냅샷을 Checkout 하지 않는다. 그냥 **저장소를 히스토리와 더불어 전부 복제**한다. 서버에 문제가 생기면 이 복제물로 다시 작업을 시작할 수 있다. **클라이언트 중에서 아무거나 골라도 서버를 복원할 수 있다**. Clone은 모든 데이터를 가진 진정한 백업니다.

게다가 대부분의 DVCS 환경에서는 리모트 저장소가 존재한다. 리모트 저장소가 많을 수도 있다. 그래서 사람들은 동시에 다양한 그룹과 다양한 방법으로 협업할 수 있다. 계층 모델 같은 중앙집중식 시스템으로는 할 수 없는 워크플로를 다양하게 사용할 수 있다.

## 짧게 보는 Git의 역사
Linux 커널은 굉장히 규모가 큰 오픈소스 프로젝트다. Linux 커널의 삶 대부분은 (1991-2002) Patch와 단순 압축 파일로만 관리했다. 2002년에 드디어 Linux 커널은 BitKeeper라고 불리는 상용 DVCS를 사용하기 시작했다.

2005년에 커뮤니티가 만드는 Linux 커널과 이익을 추구하는 회사가 개발한 BitKeeper의 관계는 틀어졌다. BitKeeper의 무료 사용이 재고된 것이다. 이 사건은 Linux 개발 커뮤니티(특히 Linux 창시자 Linus Torvalds)가 자체 도구를 만드는 계기가 됐다. Git은 BitKeeper를 사용하면서 배운 교훈을 기초로 아래와 같이 목표를 세웠다.

- 빠른 속도
- 단순한 구조
- 비선형적인 개발(수천 개의 동시 다발적인 브랜치)
- 완벽한 분산
- Linux 커널 같은 대형 프로젝트에도 유용할 것(속도나 데이터 크기 면에서)

Git은 2005년 탄생하고 나서 아직도 초기 목표를 그대로 유지하고 있다. 그러면서도 사용하기 쉽게 진화하고 성숙했다. Git은 미친 듯이 빨라서 대형 프로젝트에 사용하기도 좋다. Git은 동시다발적인 브랜치에도 끄떡없는 슈퍼 울트라 브랜칭 시스템이다.

## Git 기초
### 차이가 아니라 스냅샷
Subversion과 Subversion 비슷한 놈들과 Git의 가장 큰 차이점은 데이터를 다루는 방법에 있다. 큰 틀에서 봤을 때 VCS 시스템 대부분은 관리하는 정보가 파일들의 목록이다. CVS Subversion, Perforce, Bazaar 등의 시스템은 각 파일의 변화를 시간순으로 관리하면서 파일들의 집합을 관리한다(보통 델타 기반 버전 관리 시스템이라고 함.)

Git은 이런 식으로 데이터를 저장하지도 취급하지도 않는다. 대신 Git은 데이터를 파일 시스템 스냅샷의 연속으로 취급하고 크기가 아주 작다. Git은 커밋하거나 프로젝트의 상태를 저장할 때마다 파일이 존재하는 그 순간을 중요하게 여긴다. 파일이 달라지지 않았으면 Git은 성능을 위해서 파일을 새로 저장하지 않는다. 단지 이전 상태의 파일에 대한 링크만 저장한다. Git은 데이터를 **스냅샷의 스트림**처럼 취급한다.

### 거의 모든 명령을 로컬에서 실행
거의 모든 명령이 로컬 파일과 데이터만 사용하기 때문에 네트워크에 있는 다른 컴퓨터는 필요 없다. 대부분의 명령어가 네트워크의 속도에 영향을 받는 CVCS에 익숙하다면 Git이 매우 놀라울 것이다. 프로젝트의 모든 히스토리가 로컬 디스크에 있기 때문에 모든 명령이 순식간에 실행된다.

즉 오프라인 상태이거나 VPN에 연결하지 못해도 막힘 없이 일 할 수 있다. 네트워크에 접속하고 있지 않아도 커밋할 수 있다.

### Git의 무결성
Git은 데이터를 저장하기 전에 항상 체크섬을 구하고 그 체크섬으로 데이터를 관리한다. 그래서 체크섬을 이해하는 Git 없이는 어떠한 파일이나 디렉토리도 변경할 수 없다. 체크섬은 Git에서 사용하는 가장 기본적인(Atomic) 데이터 단위이자 Git의 기본 철학이다.

Git은 `SHA-1` 해시를 사용하여 체크섬을 만든다. 만든 체크섬은 **40자 길이의 16진수 문자열**이다. 파일의 내용이나 디렉토리 구조를 이용하여 체크섬을 구한다.

Git은 모든 것을 해시로 식별하기 때문에 이런 값은 여기저기서 보인다. 실제로 Git은 파일을 이름으로 저장하지 않고 해당 파일의 해시로 저장한다.

### Git은 데이터를 추가할 뿐
Git으로 무얼 하든 Git 데이터베이스에 데이터가 추가 된다. 되돌리거나 데이터를 삭제할 방법이 없다. 다른 VCS 처럼 Git도 커밋하지 않으면 변경사항을 잃어버릴 수 있다. 하지만, 일단 스냅샷을 커밋하고 나면 데이터를 잃어버리기 어렵다.

### 세 가지 상태
Git은 파일을 `Committed`, `Modified`, `Staged` 이렇게 세 가지 상태로 관리한다.

- Committed란 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 의미한다.
- Modified는 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 것을 말한다.
- Staged란 현재 수정한 파일을 곧 커밋할 것이라고 표시한 상태를 의미한다.

이 세 가지 상태는 Git 프로젝트의 세 가지 단계와 연결돼 있다. Git 디렉토리, 워킹 트리, Staging Area 이렇게 세 가지 단계를 이해하고 넘어가자.

Git 디렉토리는 Git이 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳을 말한다. 이 Git 디렉토리가 Git의 핵심이다. 다른 컴퓨터에 있는 저장소를 Clone 할 때 Git 디렉토리가 만들어진다.

워킹 트리는 프로젝트의 특정 버전을 Checkout 한 것이다. Git 디렉토리는 지금 작업하는 디스크에 있고 그 디렉토리 안에 압축된 데이터베이스에서 파일을 가져와서 워킹 트를 만든다.

`Staging Area`는 Git 디렉토리에 있다. 단순한 파일이고 곧 커밋할 파일에 대한 정보를 저장한다. Git에서는 기술용어로 `Index`라고 하지만, `Staging Area`라는 용어를 써도 상관 없다.

Git으로 하는 일은 기본적으로 아래와 같다.

1. 워킹 트리에서 파일을 수정한다.
2. Staging Area에 파일을 Stage 해서 커밋할 스냅샷을 만든다. 모든 파일을 추가할 수도 있고 선택하여 추가할 수도 있다.
3. Staging Area에 있는 파일들을 커밋해서 Git 디렉토리에 영구적인 스냅샷으로 저장한다.
Git 디렉토리에 있는 파일들은 Committed 상태이다. 파일을 수정하고 Staging Area에 추가했다면 Staged이다. 그리고 Checkout 하고 나서 수정했지만, 아직 Staging Area에 추가하지 않았으면 Modified이다.

### CLI
Git의 모든 기능을 지원하는 것은 CLI 뿐이다. GUI 프로그램의 대부분은 Git 기능 중 일부만 구현하기 때문에 비교적 단순하다. CLI를 사용할 줄 알면 GUI도 사용할 수 있지만 반대는 성립하지 않는다.

## Git 최초 설정
git을 설치하고 나면 Git의 사용 환경을 적절하게 설정해 주어야 한다. 환경 설정은 한 컴퓨터에서 한 번만 하면 된다. 설정한 내용은 Git을 업그레이드해도 유지된다. 언제든지 다시 바꿀 수 있는 명령어도 있다.

`git config`라는 도구로 설정 내용을 확인하고 변경할 수 있다. Git은 이 설정에 따라 동작한다. 이때 사용하는 설정 파일은 세 가지나 된다.

1. `/etc/gitconfig` 파일 : 시스템의 모든 사용자와 모든 저장소에 적용되는 설정이다. `git config --system`옵션으로 이 파일을 읽고 쓸 수 있다. (이 파일은 시스템 전체 설정파일이기 때문에 수정하려면 시스템의 관리자 권한이 필요하다.)
2. `~/.gitconfig, ~/.config/git/config` 파일 : 특정 사용자(즉 현재 사용자)에게만 적용되는 설정이다. `git config --global` 옵션으로 이 파일을 읽고 쓸 수 있다. 특정 사용자의 모든 저장소 설정에 적용된다.
3. `.git/config` : 이 파일은 Git 디렉토리에 있고 특정 저장소(혹은 현재 작업 중인 프로젝트)에만 적용된다. `--local` 옵션을 사용하면 이 파일을 사용하도록 지정할 수 있다. 하지만 기본적으로 이 옵션이 적용되어 있다. (당연히, 이 옵션을 적용하려면 Git 저장소인 디렉토리로 이동 한 후 적용할 수 있다.)

각 설정은 역순으로 우선시 된다. 그래서 `.git/config`가 `/etc/gitconfig` 보다 우선한다.

#### 사용자 정보
git을 설치하고 나서 가장 먼저 해야 하는 것은 사용자이름과 이메일 주소를 설정하는 것이다. Git은 커밋할 때마다 이 정보를 사용한다. 한 번 커밋한 후에는 정보를 변경할 수 없다.

```bash
$ git config --global user.name ""
```

